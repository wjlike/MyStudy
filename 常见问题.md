##  volatile 关键字，他是如何保证可见性，有序性

 volatile 可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在 JVM 底 层 volatile 是采用“内存屏障”来实现的。

 观察加入 volatile 关键字和没有加入 volatile 关键字时所生成的汇编代码发现，加入 volatile 关键字时，会多出一个 lock 前缀指令， lock 前缀指令实际上相当于一个内存屏障（也成内存栅栏），

内存屏障会提供 3 个功 能： 

I. 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面 的指令排到内 存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成； 

II. 它会强制将对缓存的修改操作立即写入主存；

 III. 如果是写操作，它会导致其他 CPU 中对应的缓存行无效。

 参考文章：https://blog.csdn.net/summerZBH123/article/details/80547516 

##  如何做的 MySQL 优化 

 MySQL 的优化有多种方式，我们可以从以下几个方面入手： 

 存储引擎的选择、字段类型的选择、索引的选择、分区分表、主从复制、读写分离、 SQL 优化 

 参考文章：https://blog.csdn.net/zls986992484/article/details/52860496 

##  oom 以及遇到这种情况怎么处理的，是否使用过日志分析工具 

 OOM，全称“Out Of Memory”，翻译成中文就是“内存用完了”，当 JVM 因为没有足够的 内存来为对象分配空间并且垃圾回收器也已经没有空间可回收时，就会抛出这个 error 

**内存泄露**：申请使用完的内存没有释放，导致虚拟机不能再次使用该内存，此时这段内存就泄露了，因为申请者不用了，而又不能被虚拟机分配给别人用。

**内存溢出**：申请的内存超出了JVM能提供的内存大小，此时称之为溢出。

 处理过程：首先通过内存映射分析工具 如 Eclipse Memory Analyzer 堆 dump 出的异常 堆转储进行快照解析确认内存中的对象是否是必要的 

 也就是先分清楚是 内存泄漏 Memory Leak 还是 Memory Overflow 如果是内存泄漏 可 通过工具进一步查看泄露的对象到 GC Roots 的引用链 

 就能找到泄露对象是怎么通过路径与 GC Roots 相关联导致垃圾收集器无法回收他们如 果不存在泄露 就检查堆参数 -Xmx 与 -Xms 与机器物理 内存对比是否还可以调大 从代码上检测 是否是某些对象的生命周期过长持有状态时间 过长 尝试减少代码运行期间的内存消耗。 

参考文章：https://www.cnblogs.com/ThinkVenus/p/6805495.html 

mat 内存分析工具

https://blog.csdn.net/cyuanxin/article/details/52003872



## 你们怎么保证 Redis 缓存和数据库的数据一致性？ 

 可以通过双删延时策略来保证他们的一致性。 参考文章：https://blog.kido.site/2018/12/07/db-and-cache-02 